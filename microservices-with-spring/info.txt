
Reactive microservices
  Traditionally, as Java developers, we are used to implementing synchronous communication using blocking 
  I/O, for example, a RESTful JSON API over HTTP. Using a blocking I/O means that a thread is allocated 
  from the operating system for the length of the request. If the number of concurrent requests goes up, a 
  server might run out of available threads in the operating system, causing problems ranging from longer 
  response times to crashing servers. Using a microservice architecture typically makes this problem even worse, 
  where typically a chain of cooperating microservices is used to serve a request. The more microservices involved 
  in serving a request, the faster the available threads will be drained.
Solution
  Use non-blocking I/O to ensure that no threads are allocated while waiting for processing 
  to occur in another service, that is, a database or another microservice.

A fat JAR file contains not only the classes and resource files of the application itself but also all the JAR 
  files the application depends on. This means that the fat JAR file is the only JAR file required to run the 
  application; that is, we only need to transfer one JAR file to an environment where we want to run the application 
  instead of transferring the application’s JAR file along with all the JAR files the application depends on.

Spring Data
Entity
  An entity describes the data that will be stored by Spring Data. Entity classes are, in general, annotated 
  with a mix of generic Spring Data annotations and annotations that are specific to each database technology.
  (like: @Table(name = "review") for sql dbs,  and @Document for nosql dbs)
  
Repositories
  Repositories are used to store and access data from different types of databases. In its most basic form, 
  a repository can be declared as a Java interface, and Spring Data will generate its implementation on the 
  fly using opinionated conventions. These conventions can be overridden and/or complemented by additional 
  configuration and, if required, some Java code.
  Spring Data also comes with some base Java interfaces, for example, CrudRepository, to make the definition 
  of a repository even simpler. The base interface, CrudRepository, provides us with standard methods for 
  create, read, update, and delete operations.

The core concepts in Spring Cloud Stream are as follows:
-- Message: A data structure that’s used to describe data sent to and received from a messaging system.
-- Publisher: Sends messages to the messaging system, also known as a Supplier.
-- Subscriber: Receives messages from the messaging system, also known as a Consumer.
-- Destination: Used to communicate with the messaging system. Publishers use output destinations and 
   subscribers use input destinations. Destinations are mapped by the specific binders to queues and topics 
   in the underlying messaging system.
-- Binder: A binder provides the actual integration with a specific messaging system, similar to
   what a JDBC driver does for a specific type of database.


plugins {
  id 'java'
  id 'org.springframework.boot' version '3.0.4'
  id 'io.spring.dependency-management' version '1.1.0'
}

-- The java plugin adds the Java compiler to the project.
-- The plugins org.springframework.boot and io.spring.dependency-management are declared,
   which together ensure that Gradle will build a fat JAR file and that we don’t need to specify any
   explicit version numbers on our Spring Boot starter dependencies. Instead, they are implied
   by the version of the org.springframework.boot plugin, that is, 3.0.4.

# in ./03-dockerize/ application.yml files:  Spring profiles can be used to specify the environment-specific 
  configuration, which, in this case, is a configuration that is only to be used when running the microservice 
  in a Docker container. Other examples are configurations that are specific to dev, test, and production 
  environments. Values in a profile override values from the default profile. By using YAML files, 
  multiple Spring profiles can be placed in the same file, separated by ---.

# When it comes to handling the suboptimal packaging of fat JAR files in Docker images, Spring Boot
  addressed this issue in v2.3.0, making it possible to extract the content of a fat JAR file into a number
  of folders. By default, Spring Boot creates the following folders after extracting a fat JAR file:
• dependencies, containing all dependencies as JAR files
• spring-boot-loader, containing Spring Boot classes that know how to start a Spring Boot application
• snapshot-dependencies, containing snapshot dependencies, if any
• application, containing application class files and resources

Writing automated tests that focus on persistence: 
  When writing persistence tests, we want to start a database when the tests begin and tear it down
  when the tests are complete. However, we don’t want the tests to wait for other resources to start up,
  for example, a web server such as Netty (which is required at runtime).
  Spring Boot comes with two class-level annotations tailored to this specific requirement:
- @DataMongoTest: This annotation starts up a MongoDB database when the test starts.
- @DataJpaTest: This annotation starts up a SQL database when the test starts:
   • By default, Spring Boot configures the tests to roll back updates to the SQL database to 
     minimize the risk of negative side effects on other tests. In our case, this behavior will cause 
     some of the tests to fail. Therefore, automatic rollback is disabled with the class-level 
     annotation @Transactional(propagation = NOT_SUPPORTED).

